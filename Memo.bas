Attribute VB_Name = "Memo"
''ツール・オプション・編集・　「変数の宣言を強制する」
'' Option Explicit
'
'
''スコープは明示すること'
''関数、変数ともにPublic/Privateを明示すること。
''省略した場合はPublicになるが､省略は禁止する｡
'
''理由
'
''省略時に他のプログラミング言語経験者が混乱しやすいのでスコープは明示する必要がある｡

''Integer型の使用は避ける
'
''VB6ならびにVBAのIntger型は16bitである｡
''メモリ節約の意図がない限りlong型を使用すること｡
'
''理由
'
''通常32bitOSのIntは32bitとして扱われることが多いため､混乱を抱かせる｡
''また､パフォーマンス的にLong型より若干落ちる｡この説明は下記を参照のこと｡
''MSDN The Integer, Long, and Byte Data Types

''変数の初期化を明示的に行う
'
''VB6やVBAでは規定の初期値があるが､なるべく明示的に初期化を行うこと｡
''クラスモジュールを使用した場合は､Class_Initializeにて全てのメンバ変数の初期化を行う｡
'
''変数の宣言と同時のNewは禁止
'
''宣言と同時にNewを行った場合：（禁止例）
'
''Dim reimu As New clsYukkuri
''reimu.Name = "ゆっくり霊夢"  ' ここでインスタンスを生成
''後でNewを行った場合：（正しい例）
'
''Dim reimu As clsYukkuri
''Set reimu = New clsYukkuri ' ここでインスタンスを生成
''reimu.Name = "ゆっくり霊夢"


''以下の理由により､変数宣言と同時のNewは行わない｡
''インスタンスの作成のタイミングを制御できなくなり､予期しないバグを発生する可能性がある
''オブジェクトが使用されるたびにインスタンスの有無をチェックするのでオーバーヘッドがある
'
''解説
'
''変数と同時にNewを行った場合､最初にオブジェクトにアクセスした場合にインスタンスが生成される｡
''これは､インスタンスの生存期間がプログラマの意図しないものになる可能性があることを表す｡以下のサンプルはその例になる｡
'
'    'Dim reimu As New clsYukkuri
'    'reimu.Name = "れいむ"
'    'Call reimu.TakeItEasy
'    'Set reimu = Nothing
'   ' If reimu Is Nothing Then ' Nothingチェックした時点でインスタンスが作成されてしまう
'  '      Debug.Print "削除されている"
' '   End If
''また､オブジェクトにアクセスするたびに存在チェックを行うので当然パフォーマンスも落ちる｡
''下記の動画で､これらのパフォーマンスについての計測を行っている｡
'
'
''http://www.nicovideo.jp/watch/sm20715025
'
''https://qiita.com/mima_ita/items/8b0eec3b5a81f168822d



'配列の最大と最小は明示する
'
'VBAの配列の範囲はCなどと違う｡
'Dim buf() As String
'ReDim buf(2) As String
'上記のような指定の場合、Cなどはbuf(0)〜(1)までしか使用できない。VBAの場合、デフォルトでは(0)〜(2)まで使用できる。
'Cなどと同じ範囲にしたい場合､下記のようにとりうる範囲を明示する｡
'
'Dim buf() As String
'ReDim buf(0 To 1) As String
'また､VBAは下記のコードで配列のデフォルトの最小値を変更できる｡
'
'
'Round関数の丸め処理の違いに注意する｡
'
'VBA の Round 関数は、Excel のワークシート関数 Round は挙動が異なる。
'Excel のワークシート関数 Round は、"算術型" の丸め処理を行います。この "算術型" 丸め処理では ".5" は常に切り上げらる。
'
'これに対して VBA の Round 関数は "銀行型" の丸め処理を行う。"銀行型" の丸め処理の場合は ".5" は、結果が偶数になるように丸め処理が行われ、切り上げられることも、切り捨てられることもある。




'制御処理
'判定文は全ての判定処理が実行されることに注意する
'
'下記のような判定文があった場合、A()でFalseがかえってもB()も実行される
'
'If a("TEST") = True And b("TEST") = True Then
'End If
'このため、B()が処理時間のかかる処理の場合は以下のようにする。
'
'If a("TEST") = True Then
'  IF B("TEST") = True
'  End If
'End If



'
'参照設定やCreateObjectの使用は慎重に行う｡
'
'動作環境が指定できない場合､参照設定で指定されたCOMなどが存在しないで､正常に動作しない場合がある｡
'
'動作環境を慎重に考慮する｡
'Date型は日付リテラルで指定する｡
'
'Date型に文字を入力した場合､その解釈は地域によって異なることになる｡
'
'  Dim a As Date
'  a = "12/1/1 12:0:0"
'  Debug.Print a
'この実行結果は日本と米国で異なる｡
'日本では「2012/1/1 12:00」と解釈するが、米国では「2001/1/12 12:00」と解釈する。
'
'これらを避けるため､日付リテラルとして指定すること｡
'以下のように入力すると・・・
'
'a = #12/1/2001 12:00:00 PM#
'VBEが以下のように変換してくれる｡
'
'a = #12/1/2001 12:00:00 PM#
'DLLの呼び出しの際に32bit,64bitプロセスのいづれかであるか注意する。



'Declare 句を用いる事でDLLを使用できるが、32bitか64bitか常に考えて使用すること。
'
'32 ビットプロセスのExcelからは64bitのDLLは使用できないし､64ビットプロセスのExcelから32bitのDLLは使用できない｡
'
'「Win64」という条件付きコンパイル定数の使用を検討すること。
'よくあるトラブルと対策
'実行前に必ず保存する
'
'VBAはコンパイル時に保存されない｡
'プログラムを実行してプロセスが異常終了した場合､その成果物はすべて消える｡
'
'そのため､VBAを実行する前は必ず保存をすること｡
'終了ボタンを押してから再実行すること｡



'デバッグなどを行っている場合､必ず終了ボタンを押してから再開すること｡
'標準モジュールのモジュールレベルの変数はプログラムが中断しただけでは初期化されない｡終了ボタンをおして初めて初期化される｡
'速度を求める場合､画面の更新を行わない
'
'画面の更新を中止することにより､計算途中の無駄な描画を省き速度をあげることができる｡
'
'画面の更新を中止する例:
'
'Dim i As Integer, j As Integer
'Application.ScreenUpdating = False
'For i = 1 To 100
'   For j = 1 To 10
'       Cells(j + 54, 18).Select
'       selection.value = j
'   Next j
'Next i
'Application.ScreenUpdating = True
'シートのアクセスに配列を使用するとパフォーマンスは改善する



'ワークシートを直接操作するより､配列を経由した方が速い｡ただし､メモリの使用量には注意する｡
'
'直接操作の例:
'
'Dim i As Long, j As Long, buf As Long
'For i = 1 To 10000
'   For j = 1 To 100
'       buf = Cells(i + 80, j + 2).value
'   Next j
'Next i




'モジュールレベル変数には 'm'
'（やむをえず使う）グローバル変数には'g'
'をprefixとして付けるようにしています｡Ctrl Iで変数の型は容易にわかりますが､スコープはひと目で分かりにくいことがあるためのアプリケーションハンガリアンです｡
'

'VBA , vb6, vbsの場合､システムハンガリアンも含めたハンガリアン記法で書くか否かは難しいところです｡
'
'ご提示の例のようなアプリケーションハンガリアンは､おそらく周りの同意を得るのは容易かと思いますし､私も同じ規則でやったケースも多々あります｡
'
'型名のシステムハンガリアンを導入するかどうかは､プロジェクトの人員しだいでかえます｡
'
'a. .NETプログラマーが多い場合は採用しない。
'b.vbsや型の宣言を強制できない場合は採用する
'C.MFCプログラマーが多い場合は採用する
'd.ただし､ハンガリアン記法自体に拒否感が強い環境では採用しない
'
'実際､提案するときは､提案内容を本当に読んだかどうか､測るためにハンガリアン記法を混ぜとくかもしれません｡ (多くの場合は議論になる項目なので)

